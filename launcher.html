<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="./styles.css" />
    <script
      src="https://unpkg.com/@babel/standalone@7.25.6/babel.min.js"
      integrity="sha256-aS0B0wnsaDByLfE16h4MDCP1fQFccysd1YWOcV+gbBo="
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, {
        useState,
        useEffect,
        useRef,
        useCallback,
      } from 'https://esm.sh/react@18?dev';
      import { createRoot } from 'https://esm.sh/react-dom@18/client?dev';
      import * as zebar from 'https://esm.sh/zebar@3.0';
      import { getCurrentWindow } from 'https://esm.sh/@tauri-apps/api@2.0.2/window';
      import { LogicalSize, LogicalPosition } from 'https://esm.sh/@tauri-apps/api@2.0.2/dpi';

      const tauriWindow = getCurrentWindow();

      // Capture the preset-defined window geometry before React touches it.
      let presetSize = null;
      let presetPos = null;
      Promise.all([
        tauriWindow.outerSize(),
        tauriWindow.outerPosition(),
      ]).then(([size, pos]) => {
        const scale = window.devicePixelRatio;
        presetSize = size.toLogical(scale);
        presetPos = pos.toLogical(scale);
      });

      async function resizeWindow(width, height) {
        try {
          await tauriWindow.setSize(new LogicalSize(width, height));
        } catch (err) {
          console.error('Resize failed:', err);
        }
      }

      async function positionWindow(x, y) {
        try {
          await tauriWindow.setPosition(new LogicalPosition(x, y));
        } catch (err) {
          console.error('Position failed:', err);
        }
      }

      createRoot(document.getElementById('root')).render(<App />);

      function applyTheme(theme) {
        const root = document.documentElement;
        const mapping = {
          background: '--bg',
          foreground: '--fg',
          accent: '--accent',
          hover: '--hover',
          active: '--active',
          border: '--border',
        };
        for (const [key, cssVar] of Object.entries(mapping)) {
          if (theme[key]) {
            root.style.setProperty(cssVar, theme[key]);
          }
        }
      }

      function App() {
        const [apps, setApps] = useState([]);
        const [mode, setMode] = useState('floating');
        const [isOpen, setIsOpen] = useState(false);
        const [barConfig, setBarConfig] = useState(null);
        const dropdownRef = useRef(null);

        // Load config.json on mount.
        useEffect(() => {
          fetch('./config.json')
            .then(res => res.json())
            .then(config => {
              if (config.apps) setApps(config.apps);
              if (config.mode) {
                setMode(config.mode);
                document.documentElement.dataset.mode = config.mode;
              }
              if (config.theme) applyTheme(config.theme);
              if (config.bar) {
                setBarConfig({
                  height: Math.max(config.bar.height ?? 40, 24),
                  offsetX: config.bar.offsetX ?? 0,
                });
              }
            })
            .catch(err =>
              console.error('Failed to load config.json:', err),
            );
        }, []);

        // Apply bar geometry for floating mode.
        useEffect(() => {
          if (!barConfig) return;
          if (mode === 'floating') {
            document.documentElement.style.setProperty('--btn-size', barConfig.height + 'px');
          }
        }, [barConfig, mode]);

        // Embedded mode: resize window for dropdown, restore preset size on close.
        // Auto-detect whether to flip the dropdown upward based on screen position.
        // Tauri keeps top-left fixed on resize, so bottom-positioned widgets need
        // to shift upward when the dropdown opens.
        useEffect(() => {
          if (mode !== 'embedded') return;
          const closedW = presetSize ? presetSize.width : 48;
          const closedH = presetSize ? presetSize.height : 40;

          // Button fills the preset window height.
          document.documentElement.style.setProperty(
            '--btn-size',
            closedH + 'px',
          );

          // Auto-flip: check if there's enough space below the widget.
          const dropdownHeight = Math.min(apps.length * 36 + 8, 400);
          const widgetY = presetPos ? presetPos.y : 0;
          const widgetH = presetSize ? presetSize.height : 40;
          const spaceBelow = window.screen.height - widgetY - widgetH;
          const shouldFlip = spaceBelow < dropdownHeight;

          document.documentElement.dataset.barPosition = shouldFlip ? 'bottom' : 'top';

          if (isOpen) {
            const totalH = closedH + dropdownHeight;
            if (shouldFlip && presetPos) {
              positionWindow(
                presetPos.x,
                presetPos.y - dropdownHeight,
              );
            }
            resizeWindow(Math.max(closedW, 170), totalH);
          } else {
            resizeWindow(closedW, closedH);
            if (shouldFlip && presetPos) {
              positionWindow(presetPos.x, presetPos.y);
            }
          }
        }, [isOpen, mode, apps.length]);

        // Close on Escape key.
        useEffect(() => {
          function handleKey(e) {
            if (e.key === 'Escape') setIsOpen(false);
          }
          document.addEventListener('keydown', handleKey);
          return () => document.removeEventListener('keydown', handleKey);
        }, []);

        // Close on click outside.
        useEffect(() => {
          function handleClickOutside(e) {
            if (
              dropdownRef.current &&
              !dropdownRef.current.contains(e.target)
            ) {
              setIsOpen(false);
            }
          }
          if (isOpen) {
            document.addEventListener('mousedown', handleClickOutside);
            return () =>
              document.removeEventListener(
                'mousedown',
                handleClickOutside,
              );
          }
        }, [isOpen]);

        const launchApp = useCallback(async (command) => {
          try {
            await zebar.shellExec('cmd', ['/c', 'start', command]);
          } catch (err) {
            console.error('Failed to launch:', command, err);
          }
          setIsOpen(false);
        }, []);

        return (
          <div
            className={`launcher ${mode === 'embedded' ? 'embedded' : ''}`}
            ref={dropdownRef}
          >
            <button
              className={`launcher-btn ${isOpen ? 'active' : ''}`}
              onClick={() => setIsOpen(prev => !prev)}
              title="App Launcher"
            >
              <i className="nf nf-md-apps"></i>
            </button>

            {isOpen && (
              <div className="dropdown">
                {apps.map((app, i) => (
                  <button
                    key={i}
                    className="app-item"
                    onClick={() => launchApp(app.command)}
                    title={app.name}
                  >
                    <i className={app.icon}></i>
                    <span className="app-name">{app.name}</span>
                  </button>
                ))}
              </div>
            )}
          </div>
        );
      }
    </script>
  </body>
</html>
